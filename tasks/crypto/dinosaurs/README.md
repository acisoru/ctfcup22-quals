# Crypto | Hard | dinosaurs

## Информация
Как-то раз один иностранец Bin Zhang пошутил: "Какова вероятность, что ты сегодня на улице встретишь динозавра? Правильно, 50% - либо ты его встретишь, либо нет!" Криптографы нашего завода очень оценили шутку, поэтому решили внедрить описываемый в его докладе шифр в аппаратуру на нашем заводе.
Теперь вам нужно решить, ставить ли в угол ответственных за такие решения, или нет?

## Деплой
-

## Выдать участникам
Файлы из папки public

## Описание
-

## Решение
Нам дан фильтрующий генератор с нелинейной функцией. У нелинейной функции есть переменные, для которых корреляционная (утекающая) вероятность велика - попробуем применить корреляционную атаку. Но мне удобнее работать с комбинирующими генераторами. Мы можем перейти от фильтрующего генератора к комбинирующему - как это сделать, я описал в pdf-файлике ["Переход от фильтрующего генератора к комбинирующему"](solve/Переход_от_фильтрующего_генератора_к_комбинирующему.pdf). Также для понятности я написал [скрипт](solve/filt_to_comb.py), который показывает эквивалентность двух схем.

Теперь нам надо как-то восстановить начальное заполнение регистра. В описании задания делается акцент на веротяности - самые растпространенные атаки на комбинирующие генераторы (аналогично и на фильтрующие) - это корреляционные атаки. Тепрь нужно подобрать подходящий метод. Для обычной корреляционной атаки регистр слишком длинный - атака Зигентайлера не сработает быстро, в многочлене обратной связи слишком много точек съема - быстрая атака Майера-Штафельбаха тоже не сработает. Но если обратить внимание на описание задания, там упомянут некий Bin Zhang - если поискать статьи по корреляционным атакам от данного автора, то первыми ссылками будут его статьи по порционным корреляционным атакам. На основе одной из таких статей и основывается таск - для вас я специально описал данную атаку в pdf-файлике ["корреляционная атака"](solve/Корреляционная_атака.pdf), а также реализовал её в [скрипте](solve/brek.py).

После получения начального заполнения (должно получиться одно, но если их несколько - не сильно страшно, применяем действия к каждому по очереди), просто применяем к нему действия, которые были описаны в данном по условию нам python-файлике.
## Флаг

`CUP{iZdXTOHf}`

